From: Manoj Srivastava <srivasta@debian.org>
Date: Wed, 14 Oct 2009 02:03:28 -0500
Subject: Fix infinite loop i watch code

    [topic--utmp-watch-fix]: Fix infinite loop i watch code

    With kernel 2.6.31, restorecond uses 99% of my CPU.

    This is because removing and readding the watch on utmp triggers inotify to
    return an IN_IGNORED event for the old watch descriptor.  If the watch gets
    allocated the same wd when it is readded, then restorecond thinks that utmp
    has changed, so removes and readds the watch again, potentially looping.

    With kernel <= 2.6.30, this never happened, because the kernel didn't reuse
    watch descriptors.  So the IN_IGNORED event comes with a wd that is no
    longer in use, and gets ignored.  But kernel 2.6.31 reuses the same watch
    descriptor.

    This patch fixes that by ignoring inotify events whose only bit set is
    IN_IGNORED.

    Note: it is not clear to me why it is necessary to remove and readd the
    watch in the first place.

    Patch by Martin Orr.

    Signed-off-by: Martin Orr <martin@martinorr.name>
    Signed-off-by: Manoj Srivastava <srivasta@debian.org>
---
 restorecond/watch.c |   28 +++++++++++++++-------------
 1 files changed, 15 insertions(+), 13 deletions(-)

diff --git a/restorecond/watch.c b/restorecond/watch.c
index 6a833c3..9a45cba 100644
--- a/restorecond/watch.c
+++ b/restorecond/watch.c
@@ -186,20 +186,22 @@ int watch(int fd, const char *watch_file)
 			printf("wd=%d mask=%u cookie=%u len=%u\n",
 			       event->wd, event->mask,
 			       event->cookie, event->len);
-		if (event->wd == master_wd)
-			read_config(fd, watch_file);
-		else {
-			switch (utmpwatcher_handle(fd, event->wd)) {
-			case -1:	/* Message was not for utmpwatcher */
-				if (event->len)
-					watch_list_find(event->wd, event->name);
-				break;
-			case 1:	/* utmp has changed need to reload */
+		if (event->mask & ~IN_IGNORED) {
+			if (event->wd == master_wd)
 				read_config(fd, watch_file);
-				break;
-
-			default:	/* No users logged in or out */
-				break;
+			else {
+				switch (utmpwatcher_handle(fd, event->wd)) {
+				case -1:	/* Message was not for utmpwatcher */
+					if (event->len)
+						watch_list_find(event->wd, event->name);
+					break;
+				case 1:	/* utmp has changed need to reload */
+					read_config(fd, watch_file);
+					break;
+
+				default:	/* No users logged in or out */
+					break;
+				}
 			}
 		}
 
